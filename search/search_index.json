{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"P4: Filesystem image forensics","text":"<p>The code location is at: https://github.com/fxlin/p4-fs</p> <p>We will inspect filesystem images. We will reason about the filesystem structures, extract useful information (both using existing tools and programmatically), and verify their integrity. </p>"},{"location":"#environment","title":"Environment","text":"<p>Contain some exercises requiring the root privilege, which cannot be done on granger1/2. </p> <p>Windows/Linux users: To be completed on your own machine. Windows users must use WSL2 (not WSL1).</p> <p>Mac users: use free VM service. Try one of the following solutions: </p> <ul> <li>AWS free tier https://aws.amazon.com/free</li> <li>Digital Ocean https://www.digitalocean.com/ You can have a free account. </li> <li>A Ubuntu VM on VMWare fusion, free to download as a student</li> </ul>"},{"location":"#objective","title":"Objective","text":"<ul> <li>(primary) experience with filesystem data structures</li> <li>(primary) reverse-engineering binary data </li> </ul>"},{"location":"#overview","title":"Overview","text":"<p>This project has two experiments. Each has its own description and assignments. </p> <ul> <li>exp1: Interpretation: parse given ext2 images and dump their key data structures.</li> <li>exp2: Consistency: check given ext2 images and report any inconsistency </li> </ul> <p>NOTE: depending on course offerings, students may do exp1 only, or exp1+exp2. Always refer to the syllabus.</p>"},{"location":"#important-files","title":"Important files","text":"<p>ext2_fs.h: the header file that contains many ext2 defs</p> <p>trivial.img, trivial.csv: a 64KB ext2 image and its sample dump </p> <p>EXT2_test.img, EXT2_test.csv: a 1MB ext2 image and its sample dump </p>"},{"location":"#credits","title":"Credits","text":"<p>Derived from UCLA CS111</p>"},{"location":"consistency/","title":"File System Consistency Analysis (exp2)","text":""},{"location":"consistency/#introduction","title":"INTRODUCTION:","text":"<p>A file system is an example of a large aggregation of complex and highly inter-related data structures. Such systems are often at risk for corruption, most commonly resulting from incomplete execution of what should have been all-or-none updates. Unless we can so cleverly design our data structures and algorithms as to render such errors impossible, it is usually necessary to articulate consistency assertions and develop a utility to audit those systems for consistency, and (where possible) repair any detected anomalies. </p> <p>In exp1 of this project we wrote a program to examine on-disk data structures and summarize their contents. In this second part, we will analyze those summaries to detect errors and inconsistencies.</p> <p>All previous projects have been implemented in C, which exposes the underlying system calls and is well suited for low level operations on well-defined data structures. This project involves trivial text processing (to read .csv input) and the assembly and processing of an internal state model. While this can certainly be done in C, you may find it easier to do in a higher level language (e.g., Python). You are free implement this project in any language that is supported on the departmental servers (where we will do the testing).</p>"},{"location":"consistency/#relation-to-reading-and-lectures","title":"RELATION TO READING AND LECTURES:","text":"<p>This project more deeply explores the filesystem structures.  The images we will be working with are EXT2 file systems. </p>"},{"location":"consistency/#project-objectives","title":"PROJECT OBJECTIVES:","text":"<ul> <li>Primary: reinforce the basic file system concepts of directory objects, file objects, and free space.</li> <li>Primary: reinforce the implementation descriptions provided in the text and lectures.</li> <li>Primary: gain experience examining, interpreting and processing information in complex binary data structures.</li> <li>Primary: reinforce the notions of consistency and integrity and apply them to a concrete and non-trivial problem.</li> </ul>"},{"location":"consistency/#deliverables","title":"DELIVERABLES:","text":"<p>A single tarball (<code>.tar.gz</code>) containing:</p> <ul> <li>(at least) one source module that builds/executes cleanly with no errors or warnings.</li> <li>A Makefile to build and run the deliverable program. The higher level targets should be:</li> <li>default ... build your program to produce an executable named <code>checker</code></li> <li>dist ... create the deliverable tarball</li> <li>clean ... delete all programs and output generated by the <code>Makefile</code>, and return the directory to its freshly un-tar-ed state.</li> <li>a <code>README</code> text file containing descriptions of each of the included files and any other information about your submission that you would like to bring to our attention (e.g., research, limitations, features, testing methodology).</li> </ul>"},{"location":"consistency/#project-description","title":"PROJECT DESCRIPTION:","text":"<p>Write a program to analyze a file system summary (a <code>.csv</code> file in the same format produced for the previous file system project) and report on all discovered inconsistencies. Detected inconsistencies should be reported to standard out. Execution errors (e.g., invalid arguments or unable to open required files) should be reported to standard error.</p> <p>Your executable should be called <code>checker</code> and accept a single, required, command line argument, the name of the file to be analyzed. If your language does not require pre-compilation (e.g., Python) create a default rule in your <code>Makefile</code> that merely creates a <code>checker</code> link, or prints a success message. If your language does not allow a program to have such a name, include a shell script (named <code>checker</code>) that will run your program.</p> <p>The results grading for this project will be entirely automated, and messages produced in an incorrect format may result in no points. We are providing a sanity check script that will do a simple validation of your package, and confirm correct output for a two-digit number of basic errors. For a simple clean summary, you can use the correct output sample (trivial.csv) we provided for the previous project. If you want a set of corrupted summaries to test with, you can pull down copies of the summaries (with names like <code>P3B-test_1.csv</code>) and corresponding correct output (with names like <code>P3B-test_1.err</code>) used by the sanity check script.</p> <p>Part of your score will be based on your ability to correctly recognize and report on the problems in the supplied file system summaries, but your program will also be tested on several other file systems with a wider range of anomalies. You can lose points for mis-reporting errors, failing to report errors, or for reporting errors that are not present.</p> <p>This is a summary of the errors your program should check for, and a sample error message for each:</p>"},{"location":"consistency/#block-consistency-audits","title":"Block Consistency Audits","text":"<p>Every block pointer in an I-node or indirect block should be valid (a legal data block, within the file system) or zero. Examine every single block pointer in every single I-node, direct block, indirect block, double-indirect block, and triple indirect block to ascertain that this is true. Look at all block pointers in the I-node, not merely those within the indicated file size. If any block pointer is not valid (a legal data block within the file system), an error message like one of the following (depending on precisely the nature of the incorrect pointer that is found) should be generated to stdout:</p> <pre><code>    INVALID BLOCK 101 IN INODE 13 AT OFFSET 0\n    INVALID INDIRECT BLOCK 101 IN INODE 13 AT OFFSET 12\n    INVALID DOUBLE INDIRECT BLOCK 101 IN INODE 13 AT OFFSET 268\n    INVALID TRIPLE INDIRECT BLOCK 101 IN INODE 13 AT OFFSET 65804\n    RESERVED INDIRECT BLOCK 3 IN INODE 13 AT OFFSET 12\n    RESERVED DOUBLE INDIRECT BLOCK 3 IN INODE 13 AT OFFSET 268\n    RESERVED TRIPLE INDIRECT BLOCK 3 IN INODE 13 AT OFFSET 65804\n    RESERVED BLOCK 3 IN INODE 13 AT OFFSET 0\n</code></pre> <p>An <code>INVALID</code> block is one whose number is less than zero or greater than the highest block in the file system. A <code>RESERVED</code> block is one that could not legally be allocated to any file because it should be reserved for file system metadata (e.g., superblock, cylinder group summary, free block list, ...). The logical <code>OFFSET</code> values are as described for the previous project.</p> <p>Note that the reported offsets should be block numbers (byte offsets divided by 1024). The offset associated with an indirect blocks should be that associated with the first data block it points to (as in the previous project).</p> <p>Every legal data block (every block between the end of the I-nodes and the start of the next group) should appear on on the free block list, or be allocated to exactly one file. Examine the free list to determine whether or not this is the case. If a block is not referenced by any file and is not on the free list, a message like the following should be generated to stdout:</p> <pre><code>    UNREFERENCED BLOCK 37\n</code></pre> <p>A block that is allocated to some file might also appear on the free list. In this case a message like the following should be generated to stdout:</p> <pre><code>    ALLOCATED BLOCK 8 ON FREELIST\n</code></pre> <p>If a legal block is referenced by multiple files (or even multiple times in a single file), messages like the following (depending on precisely where the references are) should be generated to stdout for each reference to that block:</p> <pre><code>    DUPLICATE BLOCK 8 IN INODE 13 AT OFFSET 0\n    DUPLICATE INDIRECT BLOCK 8 IN INODE 13 AT OFFSET 12\n    DUPLICATE DOUBLE INDIRECT BLOCK 8 IN INODE 13 AT OFFSET 268\n    DUPLICATE TRIPLE INDIRECT BLOCK 8 IN INODE 13 AT OFFSET 65804\n</code></pre> <p>Note that you will not know that a block is multiply referenced until you find the second reference. You will have to figure out a way to go back and report ALL of the references. We must report all of the references, because each of them is likely to have been corrupted.</p>"},{"location":"consistency/#i-node-allocation-audits","title":"I-node Allocation Audits","text":"<p>We can tell whether or not an I-node is allocated by looking at its type and presence in the CSV file. An allocated I-node will have some valid type (e.g., file or directory). Unallocated I-nodes (whose type should be zero) should not appear in INODE summaries, but should be in the free list. Scan through all of the I-nodes to determine which are valid/allocated. Every unallocated I-Node should be on a free I-node list. Compare your list of allocated/unallocated I-nodes with the free I-node bitmaps, and for each discovered inconsistency, a message like one of the following should be generated to stdout:</p> <pre><code>    ALLOCATED INODE 2 ON FREELIST\n    UNALLOCATED INODE 17 NOT ON FREELIST\n</code></pre>"},{"location":"consistency/#directory-consistency-audits","title":"Directory Consistency Audits","text":"<p>Every allocated I-node should be referred to by the a number of directory entries that is equal to the reference count recorded in the I-node. Scan all of the directories to enumerate all links.</p> <p>For any allocated I-node whose reference count does not match the number of discovered links, an error message like the following should be generated to stdout:</p> <pre><code>    INODE 2 HAS 4 LINKS BUT LINKCOUNT IS 5\n</code></pre> <p>This message should also be used to report unreferenced I-nodes:</p> <pre><code>    INODE 17 HAS 0 LINKS BUT LINKCOUNT IS 1\n</code></pre> <p>Directory entries should only refer to valid and allocated I-nodes. An <code>INVALID</code> I-node is one whose number is less than 1 or greater than the last I-node in the system. While scanning the directory entries, check the validity and allocation status of each referenced I-node. For any reference to an invalid or unallocated I-node, an error message like the following should be generated to stdout:</p> <pre><code>    DIRECTORY INODE 2 NAME 'nullEntry' UNALLOCATED INODE 17\n    DIRECTORY INODE 2 NAME 'bogusEntry' INVALID INODE 26\n</code></pre> <p>We also know that every directory should begin with two links, one to itself (.) and one to its parent (..). While scanning each directory, check for the correctness of these two links and, for each detected inconsistency, a message like one of the following should be generated to stdout:</p> <pre><code>    DIRECTORY INODE 2 NAME '..' LINK TO INODE 11 SHOULD BE 2\n    DIRECTORY INODE 11 NAME '.' LINK TO INODE 2 SHOULD BE 11\n</code></pre>"},{"location":"consistency/#note","title":"NOTE","text":"<p>As in the previous project, the file system summaries we use to test your submission will describe file systems with only a single group.</p>"},{"location":"consistency/#sample-damaged-file-system-summaries-and-output","title":"SAMPLE DAMAGED FILE SYSTEM SUMMARIES AND OUTPUT","text":"<p>The sanity check script will automatically download a large number of damaged file system summaries. Run your program against them, and compare your output with (what I believe to be) the correct error reports. Note that the sanity check runs are timed. If your program is implemented inefficiently (e.g. too many scans, using too much memory) it may run so slowly as to time out and fail. If this happens to you, examine your approach and look for a more efficient way to obtain the required information.</p> <p>As with the previous project, your output will be sorted before it is compared with the golden results, so the order in which you output errors is unimportant.</p>"},{"location":"consistency/#summary-of-exit-codes","title":"SUMMARY OF EXIT CODES:","text":"<ul> <li>0 ... successful execution, no inconsistencies found.</li> <li>1 ... unsuccessful execution, bad parameters or system call failure.</li> <li>2 ... successful execution, inconsistencies found.</li> </ul>"},{"location":"consistency/#submission","title":"SUBMISSION:","text":"<p>Your README file must include lines of the form:</p> <p>NAME: your (comma separted) name(s) EMAIL: your (comma separted) email address(es) ID: your (comma separted) student ID(s)</p> <p>And, if slip days are allowed on this project, and you want to use some, this too must be included in the README file:</p> <p>SLIPDAYS: #days</p> <p>If, for instance, you wanted to use two slip-days, you would add the following line:</p> <p>SLIPDAYS: 2</p> <p>Your name, student ID, and email address should also appear as comments at the top of your <code>Makefile</code> and each source file. If this is a team submission, the names, e-mail addresses, and student IDs should be comma-separated.</p> <p>Your tarball should have a name of the form <code>lab3b-</code>studentID<code>.tar.gz</code>. If this is a team submission, only one student ID need appear in the tarball's name. You can sanity check your submission with this test script. Projects that do not pass the test script are likely to receive very poor scores!</p> <p>We will test it on a departmental Linux server. You would be well advised to test your submission on that platform before submitting it.</p>"},{"location":"interpretation/","title":"File System Interpretation (exp1)","text":"<p>In this exp, we will inspect filesystem images. We will reason about how filedata and metadata are stored and maintained. </p>"},{"location":"interpretation/#objectives","title":"Objectives","text":"<ul> <li>(primary) Reinforcing understanding of ext2</li> <li>(secondary) Working with binary data structures</li> </ul>"},{"location":"interpretation/#roadmap","title":"Roadmap","text":"<ul> <li>Understand the on-disk data format of the EXT2 file system. We will mount a provided image file on your own Linux system and explore it with familiar file navigation commands and debugfs(8).</li> <li>Write a program to analyze the file system in that image file and output a summary to standard out (describing the super block, groups, free-lists, inodes, indirect blocks, and directories).</li> </ul>"},{"location":"interpretation/#prerequisites","title":"Prerequisites","text":"<pre><code>git clone https://github.com/fxlin/p4-fs\n</code></pre> <p>Required environment </p> <p>Fiddling with a whole filesystem (and disk images) requires the root privilege. So do this exp either on your Linux box, or Windows WSL2, for which you have root. WARNING: WSL1 is known to have issue with <code>mount</code>. </p> <p>(Adventurous) You MAY try it inside a QEMU emulator on the server (e.g. granger1). The problem with QEMU: you will need a system image with all the utilities, e.g. dumpe2fs, etc. Can be built with buildroot which requires some exploration. So consider this as an unbeaten path. I'll be happy to learn if you pull it off.</p> <p>Choice of programming languages</p> <p>You can use any programming language (C/C++, Python, Java...). </p> <p>C/C++ code can directly use the C header we provide to manipulate ext2 data structures; other programming languages will have to manipulate those bits per the C header. </p>"},{"location":"interpretation/#deliverables","title":"DELIVERABLES:","text":"<p>A single tarball (<code>.tar.gz</code>) containing:</p> <ul> <li>Your code, can be in any programming language (C/C++, Python, Java...). </li> <li>If your code requires compilation, include a Makefile to build and run the deliverable program. The higher level targets should be:</li> <li>default ... compile your program (with the <code>-Wall</code> and <code>-Wextra</code> options) to produce an executable </li> <li>clean ... delete all programs and output generated by the <code>Makefile</code>.</li> <li>If your code requires no compilation (e.g. written in Python), no Makefile is needed.</li> <li>The name of executable must be <code>fsdump</code>, regardless of your language choice. Btw, a Python script can be made as a standalone executable (Google it). </li> <li>A short <code>README</code> text file (NOT PDF) containing descriptions of each of the included files and any other information about your submission that you would like to bring to our attention (e.g., research, limitations, features, testing methodology).</li> <li>You do NOT need to submit any CSV file</li> </ul>"},{"location":"interpretation/#project-description","title":"PROJECT DESCRIPTION:","text":"<p>Historically, file systems were almost always been implemented as part of the operating system, running in kernel mode. Kernel code is expensive to develop, difficult to test, and prone to catastrophic failures. Within the past 15 years or so, new developments have made it possible to implement file systems in user mode, improving maintainability, and in some cases delivering even better performance than could be achieved with kernel code. All of this project will be done as user-mode software.</p> <p>To ensure data privacy and integrity, file system disks are generally protected from access by ordinary applications. Linux supports the creation, mounting, checking, and debugging of file systems stored in ordinary files. In this project, we will provide EXT2 file system images in ordinary files. Because they are in ordinary files (rather than protected disks) you can access/operate on those file system images with ordinary user mode code.</p>"},{"location":"interpretation/#part-1-exploring-an-ext2-image","title":"PART 1: Exploring an EXT2 Image","text":"<p>Follow the steps in here. </p>"},{"location":"interpretation/#part-2-summarizing-an-ext2-image","title":"PART 2: Summarizing an EXT2 Image","text":"<p>In this step, you will write a program called <code>fsdump</code> that:</p> <ul> <li>Reads a file system image, whose name is specified as a command line argument. For example, we may run your program with the above file system image using the a command like:</li> </ul> <p><code>./fsdump EXT2_test.img</code></p> <ul> <li> <p>Analyzes the provided file system image and produces (to standard out) CSV summaries of what it finds. The contents of these CSV lines described below. Your program must output these files with exactly the same formats as shown below. We will use sort(1) and diff(1) to compare your csv output with ours, so the order of output lines does not matter, but a different format (even extra white space) will make your program fail the test.</p> </li> <li> <p>You need to parse filesystem data structures using your own code. You CANNOT rely on existing ext2 libraries or tools (such as debugfs) and parse their output. </p> </li> </ul> <p>Even if you cannot mount the provided image file and run debugfs on departmental servers, your program should be able to run on departmental servers, because it does not require <code>mount</code>. </p> <p>There are six types of output lines that your program should produce, each summarizing a different part of the file system. Remember, you can always check your program's output against debugfs's output. All the information required for the summary can be manually found and checked by using debugfs. This is described here. </p> <p>We have also provided to you (for testing purposes) a much smaller image (trivial.img) as well as a correct output summary (trivial.csv).</p>"},{"location":"interpretation/#superblock-summary","title":"superblock summary","text":"<p>A single new-line terminated line, comprised of eight comma-separated fields (with no white-space), summarizing the key file system parameters:</p> <ol> <li><code>SUPERBLOCK</code></li> <li>total number of blocks (decimal)</li> <li>total number of i-nodes (decimal)</li> <li>block size (in bytes, decimal)</li> <li>i-node size (in bytes, decimal)</li> <li>blocks per group (decimal)</li> <li>i-nodes per group (decimal)</li> <li>first non-reserved i-node (decimal)</li> </ol>"},{"location":"interpretation/#group-summary","title":"group summary","text":"<p>Scan each of the groups in the file system. For each group, produce a new-line terminated line for each group, each comprised of nine comma-separated fields (with no white space), summarizing its contents.</p> <ol> <li><code>GROUP</code></li> <li>group number (decimal, starting from zero)</li> <li>total number of blocks in this group (decimal)</li> <li>total number of i-nodes in this group (decimal)</li> <li>number of free blocks (decimal)</li> <li>number of free i-nodes (decimal)</li> <li>block number of free block bitmap for this group (decimal)</li> <li>block number of free i-node bitmap for this group (decimal)</li> <li>block number of first block of i-nodes in this group (decimal)</li> </ol> <p>NOTE: of a disk, block 0 is the boot block. Therefore, group 0 has 1 fewer block than any other groups. Example: group size is 64; group 0 spans block 1--63. You can verify this by <code>dumpe2fs</code>. Despite this, in your output for group 0, still output the actual group size, e.g. 64 in the above example. </p>"},{"location":"interpretation/#free-block-entries","title":"free block entries","text":"<p>Scan the free block bitmap for each group. For each free block, produce a new-line terminated line, with two comma-separated fields (with no white space).</p> <ol> <li><code>BFREE</code></li> <li>number of the free block (decimal)</li> </ol> <p>Take care to verify that you:</p> <ol> <li>understand whether 1 means \"allocated\" or \"free\".</li> <li>have correctly understood the block number to which the first bit corresponds.</li> <li>know how many blocks are in each group, and do not interpret more bits than there are blocks in the group.</li> </ol>"},{"location":"interpretation/#free-i-node-entries","title":"free I-node entries","text":"<p>Scan the free I-node bitmap for each group. For each free I-node, produce a new-line terminated line, with two comma-separated fields (with no white space).</p> <ol> <li><code>IFREE</code></li> <li>number of the free I-node (decimal)</li> </ol> <p>Take care to verify that you:</p> <ol> <li>understand whether 1 means \"allocated\" or \"free\".</li> <li>have correctly understood the I-node number to which the first bit corresponds.</li> <li>know how many I-nodes are in each group, and do not interpret more bits than there are I-nodes in the group.</li> </ol>"},{"location":"interpretation/#i-node-summary","title":"I-node summary","text":"<p>Scan the I-nodes for each group. For each allocated (non-zero mode and non-zero link count) I-node, produce a new-line terminated line, with up to 27 comma-separated fields (with no white space). The first twelve fields are i-node attributes:</p> <ol> <li><code>INODE</code></li> <li>inode number (decimal)</li> <li>file type ('f' for file, 'd' for directory, 's' for symbolic link, '?\" for anything else)</li> <li>mode (low order 12-bits, octal ... suggested format \"%o\")</li> <li>owner (decimal)</li> <li>group (decimal)</li> <li>link count (decimal)</li> <li>time of last I-node change (mm/dd/yy hh:mm:ss, GMT)</li> <li>modification time (mm/dd/yy hh:mm:ss, GMT)</li> <li>time of last access (mm/dd/yy hh:mm:ss, GMT)</li> <li>file size (decimal)</li> <li>number of (512 byte) blocks of disk space (decimal) taken up by this file</li> </ol> <p>The number of blocks (field 12) should contain the same value as the i_blocks field of the I-node. There are a few interesting and non-obvious things about this number:</p> <ol> <li>This number is in units of 512 byte blocks, even if the file system block size is something else (e.g. 1024 or 4096 byte blocks).</li> <li>This number (times 512) may be smaller than the file size, as it includes only blocks that have actually been allocated to the file. A very large file might be sparse, in that some parts of the file may not have actually been written, and take up no disk space, but will read back as zeroes.</li> <li>This number (times 512) may be larger than the file size because it includes not only data blocks, but (single, double, and triple) indirect blocks that point to data blocks.</li> </ol> <p>For ordinary files (type 'f') and directories (type 'd') the next fifteen fields are block addresses (decimal, 12 direct, one indirect, one double indirect, one triple indirect). </p> <p>Timestamp format. Related functions: gmtime() and strftime(), both in <code>&lt;time.h&gt;</code>.  If you notice there's an offset between yours and the sample dump: make sure you print time in GMT instead of local time such as GST. </p> <p>Symbolic links. If the file length is less than the size of the block pointers (60 bytes) the file will contain zero data blocks, and the name (a text string) is stored in the space normally occupied by the block pointers (i.e. inline). </p> <p>For an inline symbolic link: </p> <ul> <li> <p>field 13: print the first four bytes of the name as unsigned int (decimal). </p> </li> <li> <p>no field 14 and beyond</p> </li> <li> <p>Example line from trivial.csv: <code>INODE,15,s,777,1028 ... 08/07/17 17:58:47,26,0,1886221359</code></p> </li> <li> <p>If you run into some bug, make sure you get the byte order right (big endian vs. little endian)</p> </li> </ul> <p>Otherwise, a symbolic link actually occupies data block(s): </p> <ul> <li>field 13 and beyond: only print the non-zero block addresses (unlike a normal file when you would print all 0s)</li> <li>Aside: for some reason, the num of blocks (field 12) can be == the actual number of blocks + 1 (e.g. there's one non-zero block, and field 12 == 2). This is also the behavior of trivial.csv and debugfs. Just follow it. </li> </ul> <p>While these rules may appear confusing, you will find examples in trivial.csv. Just make your output consistent with it!</p>"},{"location":"interpretation/#directory-entries","title":"directory entries","text":"<p>For each directory I-node, scan every data block. For each valid (non-zero I-node number) directory entry, produce a new-line terminated line, with seven comma-separated fields (no white space).</p> <ol> <li><code>DIRENT</code></li> <li>parent inode number (decimal) ... the I-node number of the directory that contains this entry</li> <li>logical byte offset (decimal) of this entry within the directory</li> <li>inode number of the referenced file (decimal)</li> <li>entry length (decimal)</li> <li>name length (decimal)</li> <li>name (string, surrounded by single-quotes). Don't worry about escaping, we promise there will be no single-quotes or commas in any of the file names.</li> </ol>"},{"location":"interpretation/#indirect-block-references","title":"indirect block references","text":"<p>The I-node summary contains a list of all 12 blocks, and the primary single, double, and triple indirect blocks. We also need to know about the blocks that are pointed to by those indirect blocks. For each I-node (file or directory), scan the single indirect blocks and (recursively) the double and triple indirect blocks. For each non-zero block pointer you find, produce a new-line terminated line with six comma-separated fields (no white space).</p> <ol> <li><code>INDIRECT</code></li> <li>I-node number of the owning file (decimal)</li> <li>(decimal) level of indirection for the block being scanned ... 1 for single indirect, 2 for double indirect, 3 for triple</li> <li>logical block offset (decimal) represented by the referenced block. If the referenced block is a data block, this is the logical block offset of that block within the file. If the referenced block is a single- or double-indirect block, this is the same as the logical offset of the first data block to which it refers.</li> <li>block number of the (1, 2, 3) indirect block being scanned (decimal) . . . not the highest level block (in the recursive scan), but the lower level block that contains the block reference reported by this entry.</li> <li>block number of the referenced block (decimal)</li> </ol> <p>What is a logical block? Given a file, let us ignore the file's physical structure (where data is actually stored, indirect blocks, sparseness, etc) and view the data in the file as a (logical) stream of bytes. If the block size is 1K (1024 bytes):</p> <ul> <li>bytes 0-1023 would be in logical block 0 of the file </li> <li>bytes 1024-2047 would be in logical block 1 of the file </li> <li>bytes 2048-3071 would be in logical block 2 of the file </li> <li>...</li> </ul> <p>You can confirm your understanding of logical block numbers by looking at the <code>INDIRECT</code> entries in the sample output.</p> <p>If an I-node contains a triple indirect block:</p> <ul> <li>the triple indirect block number would be included in the INODE summary.</li> <li><code>INDIRECT</code> entries (with level 3) would be produced for each double indirect block pointed to by that triple indirect block.</li> <li><code>INDIRECT</code> entries (with level 2) would be produced for each indirect block pointed to by one of those double indirect blocks.</li> <li><code>INDIRECT</code> entries (with level 1) would be produced for each data block pointed to by one of those indirect blocks.</li> </ul>"},{"location":"interpretation/#sample-output","title":"Sample Output","text":"<p>We have provided a very simple test file system image (trivial.img) as well as a correct output summary (trivial.csv) that you can download and test with. Your program should be able to generate (modulo line ordering) the same output. </p>"},{"location":"interpretation/#implementation-strategy","title":"Implementation strategy","text":"<p>Read through the entire document; do simple feature first; test often; backup code regularly. Have fun!</p>"},{"location":"lite/","title":"File System Interpretation w/ commands (part of exp1)","text":"<p>Reading time: 30min</p> <p>This writeup describes how to use EXISTING tools to inspect a filesystem image. No code is written.</p> <p>In this experiment, we will inspect filesystem images. We will reason about how filedata and metadata are stored and maintained. </p>"},{"location":"lite/#objectives","title":"Objectives","text":"<ul> <li>(primary) Reinforcing understanding of ext2</li> <li>(secondary) Familiarizing with Linux file tools</li> </ul>"},{"location":"lite/#roadmap","title":"Roadmap","text":"<ul> <li>Mount an ext2 filesystem image with a few dir/files. </li> <li>Use Linux tools to examine key data structures: inodes/bitmaps\u2026</li> <li>Show how such a filesystem image is created</li> </ul>"},{"location":"lite/#prerequisites","title":"Prerequisites","text":"<pre><code>git clone https://github.com/fxlin/p4-fs\n</code></pre> <p>Required environment </p> <p>Fiddling with a whole filesystem (and disk images) requires the root privilege. So do the following experiment either on your Linux box which you have root; or do it on the server (e.g. granger1), inside a QEMU emulator. The problem with QEMU: you will need a system image with all the utilities, e.g. dumpe2fs, etc. Can be built with buildroot which requires some exploration.</p> <ul> <li>Linux users: do this exp either on your local box which you have root. Or do it on the server, inside a QEMU emulator. The problem with QEMU: you will need a system image with all the utilities, e.g. dumpe2fs, etc. Can be built with buildroot which requires some exploration.</li> <li>Windows users: do this on WSL2 (not WSL1). </li> <li>Mac Users: see the landing page.</li> </ul> <p>The tools we will use </p> <ul> <li>ls: show directory content</li> <li>dd: read/write raw content of a file (or a disk partition)</li> <li>mkfs.ext2: create a new ext2 filesystem</li> <li>debugfs: ext filesystem debugger </li> <li>stat: get file status</li> <li>dumpe2fs: dump ext filesystem info</li> <li>xxd, hexdump: display binary data</li> </ul>"},{"location":"lite/#step-1-grab-the-disk-image-mount-basic-inspection","title":"Step 1. Grab the disk image, mount, &amp; basic inspection","text":"<p>The image file is a byte-to-byte dump of a small disk. The disk size is 2MB. </p> <pre><code># grab the file from this git repo (path: lite/disk.img.gz), and unzip it \ngzip -d disk.img.gz\n</code></pre> <p>How large is the disk image, compressed and decompressed? </p> <pre><code>$ ls -lh disk.img.gz\n-rwxr--r-- 1 xzl xzl 2.6K Nov 25 10:39 disk.img.gz\n\n$ ls -lh disk.img\n-rw-r--r-- 1 xzl xzl 2.0M Apr  6 13:33 disk.img\n</code></pre> <p>Because our filesystem only uses a small fraction of the disk space (we will see soon), most of these bytes are zero. That's why we compress the disk image (as .gz) for distribution. </p> <p>Next, we mount the disk image as a loop device. (Recall: a loop device treats a file as a physical disk; see our lecture slides). AGAIN, YOU WONT' BE ABLE TO DO THIS ON GRANGER1/2 (cf: the landing page)</p> <pre><code># create our mount point\n$ mkdir /tmp/myfs\n\n# mount the disk image. Note the sudo command\n$ sudo mount -o loop disk.img /tmp/myfs\n</code></pre> <p>Now we are ready to tinker with the filesystem. </p>"},{"location":"lite/#check-the-disk-usage","title":"Check the disk usage","text":"<pre><code>$ df -hP /tmp/myfs/\nFilesystem   Size Used Avail Use% Mounted on\n/dev/loop2   2.0M  21K 1.9M  2% /tmp/myfs\n</code></pre> <p>This shows that our disk size is 2.0M, of which only 2% is used. It shows the mount point (/tmp/myfs) of our  filesystem. It also shows that the kernel allocates a loop device (<code>/dev/loop2</code>) as the backing store of the filesystem. The actual device name may vary, e.g. you may see <code>/dev/loop10</code>. This is the device name of our disk (everything is a file, right?)</p>"},{"location":"lite/#check-the-filesystem-type-mount-options","title":"Check the filesystem type &amp; mount options","text":"<p>So, what's the filesystem type? We can use <code>mount</code>, which lists all filesystems currently mounted. From its output, we look for our mount point. </p> <pre><code>$ mount|grep myfs\n/tmp/disk.img on /tmp/myfs type ext2 (rw,relatime)\n</code></pre> <p><code>mount</code> shows our filesystem as ext2. It also shows the mount options (rw=readable &amp; writeable; relatime~=skipping updating a file's access time for most accesses, see details). </p>"},{"location":"lite/#list-the-directory-structure","title":"List the directory structure","text":"<pre><code>$ ls -lh /tmp/myfs/\ntotal 14K\n-rw-r--r-- 1 root root   10 Apr  6 11:44 aa\nlrwxrwxrwx 1 root root    2 Apr  6 12:30 aa-symlink -&gt; aa\ndrwx------ 2 root root  12K Apr  2 23:53 lost+found\ndrwxr-xr-x 2 root root 1.0K Apr  6 11:35 testdir\n</code></pre>"},{"location":"lite/#step-2-inspect-metadata","title":"Step 2. inspect metadata","text":"<p>Recall that an ext2 filesystem has a global \"superblock\", which is the metadata for the entire filesystem. To dump its contents, we of course can write our own program to parse the disk image. But there's already a handy tool -- <code>dumpe2fs</code>.  It will accept the disk device name (dev/loop2 in my case; this may be different in your case, see discussion above). </p> <pre><code>$ sudo dumpe2fs  /dev/loop2\ndumpe2fs 1.42.13 (17-May-2015)\nFilesystem volume name:   &lt;none&gt;\nLast mounted on:          /tmp/myfs\nFilesystem UUID:          6430eccd-11d0-4ea9-bd26-ce6e946dc02b\nFilesystem magic number:  0xEF53\nFilesystem revision #:    1 (dynamic)\nFilesystem features:      ext_attr resize_inode dir_index filetype sparse_super large_file\nFilesystem flags:         signed_directory_hash\nDefault mount options:    user_xattr acl\nFilesystem state:         clean\nErrors behavior:          Continue\nFilesystem OS type:       Linux\nInode count:              256\nBlock count:              2048\nReserved block count:     102\nFree blocks:              1990\nFree inodes:              244\nFirst block:              1\nBlock size:               1024\nFragment size:            1024\nReserved GDT blocks:      7\nBlocks per group:         8192\nFragments per group:      8192\nInodes per group:         256\nInode blocks per group:   32\nFilesystem created:       Thu Apr  2 23:53:31 2020\nLast mount time:          Thu Apr  2 23:56:50 2020\nLast write time:          Thu Apr  2 23:57:02 2020\nMount count:              2\nMaximum mount count:      -1\nLast checked:             Thu Apr  2 23:53:31 2020\nCheck interval:           0 (&lt;none&gt;)\nLifetime writes:          8 kB\nReserved blocks uid:      0 (user root)\nReserved blocks gid:      0 (group root)\nFirst inode:              11\nInode size:               128\nDefault directory hash:   half_md4\nDirectory Hash Seed:      15323132-fa4b-4822-ab37-f49b15b57487\n\nGroup 0: (Blocks 1-2047)\n  Primary superblock at 1, Group descriptors at 2-2\n  Reserved GDT blocks at 3-9\n  Block bitmap at 10 (+9), Inode bitmap at 11 (+10)\n  Inode table at 12-43 (+11)\n  1988 free blocks, 242 free inodes, 3 directories\n  Free blocks: 59-512, 514-2047\n  Free inodes: 15-256\u00a0\n</code></pre>"},{"location":"lite/#metadata-overview","title":"Metadata overview","text":"<p>It's a lot of information! From here, we can see familiar things, echoing what we have learnt about ext2 in class:</p> <ul> <li>There are 256 inodes in total (\"Inode count...\"). These inodes are pre-allocated when the filesystem is initialized. </li> <li>There are 2048 blocks (\"Block count...\". Since this disk is 2MB in total, each block is 2MB/2048=1KB)</li> <li>The first inode is inode 11 (\"First inode...)\". Which file is this? We will see soon. </li> <li>Each inode has 128 bytes (\"Inode size...\"). Recall this is for per file metadata plus a bunch of pointers to disk blocks of this file. </li> </ul>"},{"location":"lite/#block-group","title":"Block group","text":"<p>You also see \"groups\" in the above output. Recall that ext2 partitions all blocks of a disk into groups, so that access within each group has better spatial locality. The output shows that each group can have up to 8192 blocks (\"Blocks per group...\"). As our disk is as small as 2048 blocks, ext2 creates only one group (Group 0), which spans all blocks of the disk. </p>"},{"location":"lite/#bitmaps","title":"Bitmaps","text":"<p>Recall that ext2 use bitmaps to track free/used blocks as well as free/used inodes. In such a bitmap, 1 means used, 0 means free. </p> <p>Where are the bitmaps stored on disk? Check the last few lines of the output. Block bitmap starts from block 10; inode bitmap starts from block 11. Block 12-43 are for the actual inodes. </p> <p>Let's dump the bitmap contents from the disk image. </p> <pre><code># dump inode bitmap. 256 inodes (display in 32 octets). Bitmap at block 11. \n$ sudo dd if=/dev/loop2 bs=1024 skip=11 count=1 status=none |xxd -b -l 32\n00000000: 11111111 00111111 00000000 00000000 00000000 00000000  .?....\n00000006: 00000000 00000000 00000000 00000000 00000000 00000000  ......\n0000000c: 00000000 00000000 00000000 00000000 00000000 00000000  ......\n00000012: 00000000 00000000 00000000 00000000 00000000 00000000  ......\n00000018: 00000000 00000000 00000000 00000000 00000000 00000000  ......\n0000001e: 00000000 00000000                                      ..\n\u00a0\n# dump block bitmap. 2048 blocks (256 display octets). Bitmap at block 10\n$ sudo dd if=/dev/loop2 bs=1024 skip=10 count=1 status=none |xxd -b -l 256\n00000000: 11111111 11111111 11111111 11111111 11111111 11111111  ......\n00000006: 11111111 00000011 00000000 00000000 00000000 00000000  ......\n0000000c: 00000000 00000000 00000000 00000000 00000000 00000000  ......\n00000012: 00000000 00000000 00000000 00000000 00000000 00000000  ......\n00000018: 00000000 00000000 00000000 00000000 00000000 00000000  ......\n0000001e: 00000000 00000000 00000000 00000000 00000000 00000000  ......\n00000024: 00000000 00000000 00000000 00000000 00000000 00000000  ......\n</code></pre> <p>In the commands above, <code>dd</code> will read the contents of the disk device (note: your /dev/loop device name may vary). \"bs=1024 skip=11 count=1\" means that <code>dd</code> will skip the first 11 blocks and read in 1 block, using 1024 bytes as the block size. </p> <p>note \"blocks\" here are just data blocks for dd to read in; it's orthogonal to disk blocks)</p> <p>The content of the read block is piped to <code>xxd</code>, whose job is to display the content nicely in binary format. \"-b\" means xxd will display every bit. \"-l\" means the number of \"octets\" to display. Each octets is a \"display group\" of eight characters (e.g. \"11111111\"). Since we are display bits, each chaterters is a bit and one octet is a byte. </p>"},{"location":"lite/#step-3-inspect-per-file-metadata","title":"Step 3. Inspect per-file metadata","text":""},{"location":"lite/#check-the-directories-again","title":"Check the directories again","text":"<p>We can use <code>ls</code> to get more information. </p> <pre><code>$ ls -ila\ntotal 31\n    2 drwxr-xr-x  4 root root  1024 Apr  6  2020 .\n57346 drwxrwxrwt 39 root root 16384 May  4 16:07 ..\n   12 -rw-r--r--  1 root root    10 Apr  6  2020 aa\n   14 lrwxrwxrwx  1 root root     2 Apr  6  2020 aa-symlink -&gt; aa\n   11 drwx------  2 root root 12288 Apr  2  2020 lost+found\n   13 drwxr-xr-x  2 root root  1024 Apr  6  2020 testdir\n\n$ ls -ila testdir/\ntotal 2\n13 drwxr-xr-x 2 root root 1024 Apr  6 11:35 .\n 2 drwxr-xr-x 4 root root 1024 Apr  6 11:35 ..\n</code></pre> <p>Here \"-i\" means to print the inode number; \"-l\" asks for the long listing format; \"-a\" asks for listing files/dirs that start with \".\" which are normally hidden. </p> <p>In the output, \"total\" shows the number of blocks used by the listed directories. The first column shows the inode number for each file/dir. For instance, inode 12 is for file \"aa\". </p> <p>From dump2efs we know the first inode is inode 11. Do you see it here? </p>"},{"location":"lite/#dump-inode-contents","title":"Dump inode contents","text":"<p>We will use <code>debugfs</code>, which is a powerful debugger for the ext family of filesystems (ext2/3/4). </p> <pre><code># inode 12. testfile \u201caa\u201d\n$ sudo debugfs -R \"stat &lt;12&gt;\" /dev/loop2\nInode: 12   Type: regular    Mode:  0644   Flags: 0x0\nGeneration: 4138714773    Version: 0x00000001\nUser:     0   Group:     0   Size: 10\nFile ACL: 0    Directory ACL: 0\nLinks: 1   Blockcount: 2\nFragment:  Address: 0    Number: 0    Size: 0\nctime: 0x5e8b4e5f -- Mon Apr  6 11:44:31 2020\natime: 0x5e8b4e4d -- Mon Apr  6 11:44:13 2020\nmtime: 0x5e8b4e5f -- Mon Apr  6 11:44:31 2020\nBLOCKS:\n(0):513\nTOTAL: 1\n\u00a0\n# inode 2. root dir\n$ sudo debugfs -R \"stat &lt;2&gt;\" /dev/loop2\nInode: 2   Type: directory    Mode:  0755   Flags: 0x0\nGeneration: 0    Version: 0x00000002\nUser:     0   Group:     0   Size: 1024\nFile ACL: 0    Directory ACL: 0\nLinks: 4   Blockcount: 2\nFragment:  Address: 0    Number: 0    Size: 0\nctime: 0x5e8b4c40 -- Mon Apr  6 11:35:28 2020\natime: 0x5e8b4c41 -- Mon Apr  6 11:35:29 2020\nmtime: 0x5e8b4c40 -- Mon Apr  6 11:35:28 2020\nBLOCKS:\n(0):44\nTOTAL: 1\n</code></pre> <p>To  invoke debugfs, we supply the disk device name (e.g. /dev/loop2) and a command (-R ...) that we want debugfs to execute. In this case, our command is \"stat\", which is to dump contents of a given inode, e.g. inode 12 (file \"aa\") and inode 2 (directory \"/\"). More debugfs details here. </p> <p>So much information to see from inodes! File types (\"regular\" and \"directory\"), access times, blocks, etc. These are exactly what we mentioned in the lectures. </p> <p>There are alternative debugfs commands that show same information but in a slight different format: </p> <pre><code># Showing inodes and type (2=dir, 1=file)\n$ sudo debugfs -R \"ls -l &lt;2&gt;\" /dev/loop2\n      2   40755 (2)      0      0    1024  6-Apr-2020 11:35 .\n      2   40755 (2)      0      0    1024  6-Apr-2020 11:35 ..\n     11   40700 (2)      0      0   12288  2-Apr-2020 23:53 lost+found\n     12  100644 (1)      0      0       0  2-Apr-2020 23:56 aa\n     13   40755 (2)      0      0    1024  6-Apr-2020 11:35 testdir\n\n# dump the block IDs used by the root dir\n$ sudo debugfs -R \"blocks /.\" /dev/loop2\ndebugfs 1.42.13 (17-May-2015)\n44\n</code></pre> <p>Keep in mind: all such information comes from inodes. </p>"},{"location":"lite/#step-4-inspect-filedata","title":"Step 4. Inspect filedata","text":""},{"location":"lite/#a-directory","title":"A directory","text":"<p>Recall a directory is nothing but a special file. Let's dump the content of the root dir \"/\". We've learnt that the root dir (\"/\") has inode 2. Fire up debugfs!</p> <pre><code>$ sudo debugfs -R \"cat &lt;2&gt;\" /dev/loop2 | hexdump -C\ndebugfs 1.42.13 (17-May-2015)\n00000000  02 00 00 00 0c 00 01 02  2e 00 00 00 02 00 00 00  |................|\n00000010  0c 00 02 02 2e 2e 00 00  0b 00 00 00 14 00 0a 02  |................|\n00000020  6c 6f 73 74 2b 66 6f 75  6e 64 00 00 0c 00 00 00  |lost+found......|\n00000030  0c 00 02 01 61 61 00 00  0d 00 00 00 c8 03 07 02  |....aa..........|\n00000040  74 65 73 74 64 69 72 00  00 00 00 00 00 00 00 00  |testdir.........|\n00000050  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00000400\n</code></pre> <p>Here, \"cat &lt;2&gt;\" is for debugfs to dump the raw content of file with inode 2. The content is piped to <code>hexdump</code>, which nicely formats the data in hex format. \"-C\" tells hexdump to put hex display  (left) and the ASCII display (right) side by side. ASCII is for human to quickly eyeball interesting textual strings. </p> <p>the last row, 0400, mark the end offset of the file. </p> <p>What we see here? \"lost+found\", \"aa\", \"testdir\" ... They are the filenames belonging to \"/\". So, \"/\" indeed stores the names of enclosed files. </p>"},{"location":"lite/#a-regular-file","title":"A regular file","text":"<p>inode 12 is for file \"aa\", which has one line \"mycontent\". We could ask debugfs to dump that info. </p> <pre><code>sudo debugfs -R \"cat &lt;12&gt;\" /dev/loop10 | hexdump -C\ndebugfs 1.44.1 (24-Mar-2018)\n00000000  6d 79 63 6f 6e 74 65 6e  74 0a                    |mycontent.|\n0000000a\n</code></pre> <p>Alternatively, we can locate the block of the file (we know it only spans 1 block) and dump the content of that block. </p> <pre><code>$ sudo debugfs -R \"blocks &lt;12&gt;\" /dev/loop2\ndebugfs 1.42.13 (17-May-2015)\n513\n\n# direct inspect block 513 on the disk image\n$ sudo dd if=/dev/loop2 bs=1024 skip=513 count=1 status=none |hexdump -C\n00000000  6d 79 63 6f 6e 74 65 6e  74 0a 00 00 00 00 00 00  |mycontent.......|\n00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00000400\n</code></pre> <p>The first command shows the block is 513. The second command directly dump block 513. We see the content \"mycontent\"!</p>"},{"location":"lite/#a-symbolic-link","title":"A symbolic link","text":"<p>File \"aa-symlink\" is a symbolic link pointing to file \"aa\". </p> <pre><code>$ ls -ila\ntotal 55\n      2 drwxr-xr-x  4 root root  1024 Apr  6 12:30 .\n5636097 drwxrwxrwt 38 root root 36864 Apr  6 12:31 ..\n     12 -rw-r--r--  1 root root    10 Apr  6 11:44 aa\n     14 lrwxrwxrwx  1 root root     2 Apr  6 12:30 aa-symlink -&gt; aa\n     11 drwx------  2 root root 12288 Apr  2 23:53 lost+found\n     13 drwxr-xr-x  2 root root  1024 Apr  6 11:35 testdir\n</code></pre> <p>Recall that a symbolic link is a special file containing the path of another file (\"aa\" in our case). aa-symlink and aa should be two files, i.e. having separate inodes. This is confirmed:  inode 12 is for \"aa\" and inode 14 is for \"aa-symlink\". </p> <p>Can we inspect the content of \"aa-symlink\"? We expect to see the string \"aa\" there. However, this seems not as straightforward: </p> <pre><code>xzl@precision[myfs]$ stat aa-symlink\n  File: 'aa-symlink' -&gt; 'aa'\n  Size: 2               Blocks: 0          IO Block: 1024   symbolic link\nDevice: 702h/1794d      Inode: 14          Links: 1\nAccess: (0777/lrwxrwxrwx)  Uid: (    0/    root)   Gid: (    0/    root)\nAccess: 2020-04-06 12:31:13.000000000 -0400\nModify: 2020-04-06 12:30:57.000000000 -0400\nChange: 2020-04-06 12:30:57.000000000 -0400\n Birth: -\n</code></pre> <p>So there is not block for \"aa-symlink\" (Blocks: 0)? The reason is that the string is inlined in the inode. So no block is used. </p> <p>Symbolic links are also filesystem objects with inodes. For all symlink shorter than 60 bytes long, the data is stored within the inode itself; it uses the fields which would normally be used to store the pointers to data blocks. This is a worthwhile optimisation as it we avoid allocating a full block for the symlink, and most symlinks are less than 60 characters long. https://www.nongnu.org/ext2-doc/ext2.html</p>"},{"location":"lite/#step-0-initialize-the-filesystem","title":"Step 0. Initialize the filesystem","text":"<p>Why we go back to step 0? Because this is how we created the disk image and initialized the filesystem that we gave to you in the first place. Let's close the loop. </p>"},{"location":"lite/#create-a-disk-image","title":"Create a disk image","text":"<pre><code>xzl@precision[tmp]$ dd if=/dev/zero of=/tmp/disk.img bs=2M count=1\n1+0 records in\n1+0 records out\n2097152 bytes (2.1 MB, 2.0 MiB) copied, 0.00403917 s, 519 MB/s\n</code></pre> <p>We see <code>dd</code> above. It's a simple tool write/read contents to/from a file. We use it to create a  file of 2MB (note bs, the block size). \"if\" means input file, i.e. where we get content from. \"/dev/zero\" is a special (or pseudo) file implemented by the kernel. Whenever you read from it, the kernel will just return 0. As a result, disk.img contains all zeros. </p> <p>Now, \"disk.img\" is just a normal file. Nothing special. </p>"},{"location":"lite/#set-up-a-loop-device-atop-the-disk-image","title":"Set up a loop device atop the disk image","text":"<pre><code>xzl@precision[tmp]$ sudo losetup -fP disk.img\nxzl@precision[tmp]$ losetup -a\n/dev/loop1: []: (/tmp/disk.img)\n</code></pre> <p>To be able to create a filesystem on the disk image, we first ask the kernel to set up a loop device atop the disk image (disk.img). <code>losetup</code> is for this purpose. \"-f\" find the first unused loop device; \"-P\" force scanning the partition table. Details. </p>"},{"location":"lite/#initialize-an-ext2-filesystem","title":"Initialize an ext2 filesystem","text":"<pre><code>$ sudo mkfs.ext2 /dev/loop1\nmke2fs 1.42.13 (17-May-2015)\nDiscarding device blocks: done\nCreating filesystem with 2048 1k blocks and 256 inodes\n\u00a0\nAllocating group tables: done\nWriting inode tables: done\nWriting superblocks and filesystem accounting information: done\n</code></pre> <p>The superblock, all inodes, bitmaps... are created at this moment. We end up having a blank ext2 filesystem. </p> <p>Check our new filesystem is mounted, create the files/dirs for testing (the ones you have tinkered with), and unmount which writes the contents back to disk.img: </p> <pre><code>$ mount |grep myfs\n/dev/loop1 on /tmp/myfs type ext2 (rw,relatime)\n\n$ cd /tmp/myfs\n$ sudo echo 'test' &gt; aa\n$ sudo mkdir testdir\n$ sudo ln -s aa aa-symlink\n\n$ sudo umount /tmp/myfs\n</code></pre>"},{"location":"lite/#inspect-the-disk-image","title":"Inspect the disk image","text":"<pre><code>$ ls -la disk.img\n-rw-r--r-- 1 xzl xzl 2097152 Apr  6 13:33 disk.img\n\n# the \u201cfile\u201d utility \u2013 smart enough to detect a filesystem within\n$ file disk.img\ndisk.img: Linux rev 1.0 ext2 filesystem data, UUID=6430eccd-11d0-4ea9-bd26-ce6e946dc02b (large files)\n\n# there will be tons of \u20180\u2019s. So zip it for distributing\n$ gzip disk.img\n$ ls -la disk.img.gz\n-rw-r--r-- 1 xzl xzl 2657 Apr  6 13:33 disk.img.gz\n</code></pre>"},{"location":"old/wsl/","title":"Wsl","text":""},{"location":"old/wsl/#setting-up-windows-wsl-for-the-experiment","title":"Setting up Windows WSL for the experiment","text":"<p>Dec/11/2020. Contributed by Andrew Jackman (aj6eb). </p> <p>(Felix: These are verified to work. Some steps may be overkill though. TODO: validate &amp; simplify. )</p> <ul> <li> <p>Install WSL  see https://docs.microsoft.com/en-us/windows/wsl/install-win10     You want to opt in to the dev builds for windows insider program to get a build capable of the simplified install if you want to go that route. Taking the more involved manual option doesnt look to bad either </p> </li> <li> <p>Get Ubuntu version from Microsoft store (I chose v20.04 LTS) </p> </li> <li> <p>If you run into a sudo command that will not run because of conflicts with bash then take a look at https://askubuntu.com/questions/103643/cannot-echo-hello-x-txt-even-with-sudo </p> </li> <li> <p>Commands for hard linking (I know we talked about it in class but I couldn't remember which session) https://www.cyberciti.biz/faq/creating-hard-links-with-ln-command/</p> </li> </ul>"}]}